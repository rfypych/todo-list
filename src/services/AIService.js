// AI Service for generating questions using OpenRouter API
class AIService {
  constructor() {
    this.apiKey = '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';
    this.model = 'meta-llama/llama-4-maverick:free';
    this.baseUrl = 'https://openrouter.ai/api/v1/chat/completions';
  }

  // Generate questions based on task content
  async generateQuestions(taskTitle, taskDescription, options = {}) {
    const {
      difficulty = 'medium', // 'easy', 'medium', 'hard'
      questionType = 'multiple_choice', // 'multiple_choice', 'essay', 'true_false', 'fill_in_blanks', 'matching'
      numQuestions = 3, // number of questions to generate
      bloomLevel = 'understanding' // 'knowledge', 'understanding', 'application', 'analysis', 'synthesis', 'evaluation'
    } = options;

    try {
      console.log('Generating questions for task:', taskTitle);
      console.log('Options:', { difficulty, questionType, numQuestions, bloomLevel });

      // Construct the prompt for the AI
      const prompt = this._constructPrompt(taskTitle, taskDescription, difficulty, questionType, numQuestions, bloomLevel);

      // Make the API request
      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
          'HTTP-Referer': window.location.href, // Required by OpenRouter
          'X-Title': 'Todo List Question Generator' // Optional but helpful for OpenRouter
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            { role: 'system', content: 'You are an educational assistant that generates high-quality questions based on learning content.' },
            { role: 'user', content: prompt }
          ],
          temperature: 0.7,
          max_tokens: 1000
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error('Error from OpenRouter API:', errorData);
        throw new Error(`API error: ${response.status} ${errorData.error?.message || 'Unknown error'}`);
      }

      const data = await response.json();
      console.log('API response:', data);

      // Extract the generated questions from the response
      const generatedContent = data.choices[0]?.message?.content;
      if (!generatedContent) {
        throw new Error('No content generated by the AI');
      }

      return {
        questions: this._parseQuestions(generatedContent, questionType),
        rawResponse: generatedContent
      };
    } catch (error) {
      console.error('Error generating questions:', error);
      throw error;
    }
  }

  // Construct the prompt for the AI based on parameters
  _constructPrompt(taskTitle, taskDescription, difficulty, questionType, numQuestions, bloomLevel) {
    let questionTypeDescription;
    switch (questionType) {
      case 'multiple_choice':
        questionTypeDescription = 'multiple choice questions with 4 options each, clearly marking the correct answer';
        break;
      case 'essay':
        questionTypeDescription = 'open-ended essay questions that require detailed written responses';
        break;
      case 'true_false':
        questionTypeDescription = 'true/false questions, clearly marking the correct answer';
        break;
      case 'fill_in_blanks':
        questionTypeDescription = 'fill-in-the-blank questions, providing the correct answers';
        break;
      case 'matching':
        questionTypeDescription = 'matching questions with items to match in two columns';
        break;
      default:
        questionTypeDescription = 'multiple choice questions with 4 options each';
    }

    let bloomDescription;
    switch (bloomLevel) {
      case 'knowledge':
        bloomDescription = 'testing recall of facts and basic concepts';
        break;
      case 'understanding':
        bloomDescription = 'testing comprehension and ability to explain ideas';
        break;
      case 'application':
        bloomDescription = 'testing ability to use information in new situations';
        break;
      case 'analysis':
        bloomDescription = 'testing ability to draw connections among ideas';
        break;
      case 'synthesis':
        bloomDescription = 'testing ability to create new content from the concepts';
        break;
      case 'evaluation':
        bloomDescription = 'testing ability to justify a position or decision';
        break;
      default:
        bloomDescription = 'testing comprehension and ability to explain ideas';
    }

    return `
Generate ${numQuestions} ${difficulty} difficulty ${questionTypeDescription} about the following topic:

Title: ${taskTitle}
Description: ${taskDescription || 'No additional description provided.'}

The questions should be at the "${bloomLevel}" level of Bloom's Taxonomy, ${bloomDescription}.

Format the output as follows:
1. Question: [Question text]
${questionType === 'multiple_choice' ? 'A) [Option A]\nB) [Option B]\nC) [Option C]\nD) [Option D]\nCorrect Answer: [Letter]' :
 questionType === 'true_false' ? 'True or False\nCorrect Answer: [True/False]' :
 questionType === 'fill_in_blanks' ? '[Question with _____ for blanks]\nCorrect Answer: [Answer]' :
 questionType === 'matching' ? 'Column A:\n1. [Item 1]\n2. [Item 2]\nColumn B:\nA. [Match A]\nB. [Match B]\nCorrect Matches: 1-[Letter], 2-[Letter]' :
 'Suggested Answer: [Brief outline of what a good answer would include]'}

2. Question: [Question text]
...

Please ensure the questions are directly relevant to the content, challenging but fair, and cover different aspects of the topic.
`;
  }

  // Parse the generated content into structured questions
  _parseQuestions(content, questionType) {
    // Split the content by question numbers (1., 2., etc.)
    const questionBlocks = content.split(/\d+\.\s+Question:/);

    // Remove the first element if it's empty or contains introductory text
    const questions = questionBlocks.slice(1).map(block => {
      const questionText = block.trim();

      // Different parsing logic based on question type
      switch (questionType) {
        case 'multiple_choice': {
          const questionParts = questionText.split(/\n(?=[A-D]\))/);
          const questionStatement = questionParts[0].trim();

          const options = {};
          let correctAnswer = '';

          // Extract options and correct answer
          questionParts.slice(1).forEach(part => {
            const match = part.match(/^([A-D])\)\s+(.+)$/);
            if (match) {
              options[match[1]] = match[2].trim();
            }
          });

          // Find the correct answer
          const correctMatch = questionText.match(/Correct Answer:\s+([A-D])/);
          if (correctMatch) {
            correctAnswer = correctMatch[1];
          }

          return {
            type: 'multiple_choice',
            question: questionStatement,
            options,
            correctAnswer
          };
        }

        case 'essay': {
          const parts = questionText.split(/\nSuggested Answer:/);
          return {
            type: 'essay',
            question: parts[0].trim(),
            suggestedAnswer: parts[1] ? parts[1].trim() : ''
          };
        }

        case 'true_false': {
          const parts = questionText.split(/\nCorrect Answer:/);
          return {
            type: 'true_false',
            question: parts[0].replace(/True or False/, '').trim(),
            correctAnswer: parts[1] ? parts[1].trim() : ''
          };
        }

        case 'fill_in_blanks': {
          const parts = questionText.split(/\nCorrect Answer:/);
          return {
            type: 'fill_in_blanks',
            question: parts[0].trim(),
            correctAnswer: parts[1] ? parts[1].trim() : ''
          };
        }

        case 'matching': {
          const columnA = [];
          const columnB = [];
          const matches = {};

          // Extract Column A
          const columnAMatch = questionText.match(/Column A:(\n[\s\S]*?)(?=Column B:)/);
          if (columnAMatch) {
            columnAMatch[1].trim().split('\n').forEach(item => {
              const match = item.match(/(\d+)\.\s+(.+)/);
              if (match) {
                columnA.push({ id: match[1], text: match[2].trim() });
              }
            });
          }

          // Extract Column B
          const columnBMatch = questionText.match(/Column B:(\n[\s\S]*?)(?=Correct Matches:|$)/);
          if (columnBMatch) {
            columnBMatch[1].trim().split('\n').forEach(item => {
              const match = item.match(/([A-Z])\.\s+(.+)/);
              if (match) {
                columnB.push({ id: match[1], text: match[2].trim() });
              }
            });
          }

          // Extract Correct Matches
          const matchesMatch = questionText.match(/Correct Matches:\s+(.*)/);
          if (matchesMatch) {
            matchesMatch[1].split(',').forEach(match => {
              const parts = match.trim().match(/(\d+)-([A-Z])/);
              if (parts) {
                matches[parts[1]] = parts[2];
              }
            });
          }

          return {
            type: 'matching',
            columnA,
            columnB,
            correctMatches: matches
          };
        }

        default:
          return {
            type: 'unknown',
            rawContent: questionText
          };
      }
    });

    return questions;
  }
}

// Create a singleton instance
const aiService = new AIService();
export default aiService;
